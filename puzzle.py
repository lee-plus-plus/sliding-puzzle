# framework of digit sliding puzzle game
import numpy as np

'''
for simlicity, no class is used

state: store the position of each digits in a 2d numpy matrix, e.g., 
    state = [[  0,  1,  2,  3 ], 
             [  4,  5,  6,  7 ], 
             [  8,  9, 10, 11 ], 
             [ 12, 13, 14, 15 ]]

action: the moving direction of the vacancy, stored as a 2d numpy vector, e.g., 
    action = [-1, 0]

action_space: the set of legal action for a given state, e.g., 
    action_space = [[-1, 0], [1, 0], [0, 1]]

'''



# width of game board
width = 4
# action space (up, down, left, and right)
whole_action_space = [np.array([-1, 0]), np.array([1, 0]), np.array([0, -1]), np.array([0, 1])]
# target state (digits placed in sequence)
tgt_state = np.reshape(np.arange(width ** 2), [width, width]).astype(int)



# reset the width of game board
def reset_width(new_width):
    global width, tgt_state
    width = new_width
    tgt_state = np.reshape(np.arange(width ** 2), [width, width]).astype(int)

# return the vacancy's position
def get_vacancy_position(state):
    pos = np.argwhere(state == 0)[0]
    return pos

# return whether state_1 equals to state_2
def is_equal(state_1, state_2):
    return (state_1 == state_2).all()

# return whether the vacancy's position is in [0...width-1, 0...width-1]
def is_pos_inside(pos):
    return np.all([0, 0] <= pos) and np.all(pos <= [width-1, width-1])

# get legal action space of given state
def get_action_space(state):
    vacancy_pos = get_vacancy_position(state)
    action_space = [action for action in whole_action_space if is_pos_inside(vacancy_pos + action)]
    return np.array(action_space)

# get the action-performed state, copied
def get_next_state(state, action):
    pos = get_vacancy_position(state)
    next_pos = pos + action
    next_state = np.copy(state) # deep copy
    next_state[pos[0], pos[1]], next_state[next_pos[0], next_pos[1]] = next_state[next_pos[0], next_pos[1]], next_state[pos[0], pos[1]]
    return next_state

# print state to terminal as a matrix
def print_state(state):
    for i in range(width):
        for j in range(width):
            print('%3d ' % state[i][j], end='') if state[i][j] != 0 else print('    ', end='')
        print()

# get a legal random state, generated by shulffling, copied
def get_random_state(shuffle_step=width**2):
    state = np.copy(tgt_state) # deep copy
    
    for i in range(shuffle_step):
        action_space = get_action_space(state)
        np.random.shuffle(action_space)
        action = action_space[0]
        state = get_next_state(state, action)
    return state



if __name__ == '__main__':
    # demostration
    state = get_random_state(shuffle_step=5)

    print()
    print('%dx%d digit sliding puzzle ' % (width, width))

    for i in range(10):
        if is_equal(state, tgt_state):
            break

        action_space = get_action_space(state)

        print('state at present: ')
        print_state(state)

        # print('select a action')
        # for i in range(len(action_space)):
        #     print('[{}]: {}'.format(i, action_space[i]))
        # action_idx = int(input('>> '))
        action_idx = np.random.randint(len(action_spaceo))

        state = get_next_state(state, action_space[action_idx])

    print('state at present: ')
    print_state(state)
    print('you win! ')
